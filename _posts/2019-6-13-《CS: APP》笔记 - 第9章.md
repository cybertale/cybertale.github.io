---
layout: post
title: 《CS: APP》第9章 - 虚拟内存
author: 宋强
tags: linux
date: 2019-06-13 21:49 +0800
---

# 虚拟内存的主要工作逻辑

虚拟内存的主要概念是将主存看作一块磁盘区域的高速缓存，虚拟内存最大大小由CPU寻址能力决定。例如一个32位计算机，虚拟内存假设为8GB，但是实际物理内存只有4GB，虚拟内存系统将这些内存的最小单位定为页，通常的大小为4KB或者8KB，之后CPU如果想要访问哪一个虚拟内存地址时，将虚拟内存地址给MMU，MMU查询页表，页表中包含内存访问权限和当前内存页在主存或者磁盘的位置，如果在主存中则生成主存物理地址访问主存将数据返回，如果不在主存中则生成缺页中断，由操作系统将缺少的页由磁盘换到主存，如果此时虚拟内存满了，使用算法找到最少访问的页，判断其是否需要写回磁盘后从主存中替换出去更新页表（页表是操作系统维护的）。缺页中断处理完成后会重新将虚拟内存再送到MMU，MMU此时肯定会发生页表命中，就会取回数据。

```mermaid
graph TD;
    A-->B;
    A-->C;
    B-->D;
    C-->D;
```

虚拟地址的页内偏移与物理地址的页内偏移是相同的。

## TLB（Translation Lookaside Buffer）与高速缓存

TLB与高速缓存实际上做的都是缓存的功能

### TLB

页表本身是存储在主存中的，MMU需要查询主存去查页是否在主存中，为了加快这个进程，MMU内部自己集成了一个小的缓存TLB，这样根据局部性原理查询的时候就可以先查TLB，速度非常快。

### 高速缓存

高速缓存是给主存和MMU之间的，高速缓存通常是物理寻址，也就是说MMU在查询页表得到物理地址后，将物理地址送到高速缓存，如果高速缓存命中则返回数据，否则高速缓存会查询主存之后返回数据。

## 多级页表

单级页表的缺点是非常明显的，当虚拟内存和物理内存的大小都变大时，页表的条目变多，页表占的空间变的非常大，解决这个问题的方法通常是采用多级页表，直到分割到后面的大小为4KB或者8KB。

## 进程独立页表

现代操作系统为了给各个进程提供独立的虚拟寻址空间，采用进程独立页表，也就是系统不维护一个统一的页表，而是每个进程有自己的一个页表，而页表中的各个页或者段可以是共享的或者是私有的。

# malloc：在虚拟地址空间的堆中申请一段空间

# mmap：将一个文件映射到虚拟地址空间

# ioremap：将一个物理地址映射到虚拟地址空间

使用