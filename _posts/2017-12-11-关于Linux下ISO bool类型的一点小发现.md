---
layout: post
title: 关于Linux下ISO bool类型的一点小发现
author: 宋强
tags: Linux bool
date: 2017-12-11 01:40 +0800
---

我在写C语言指针+1实际增加的大小 这个文章的程序的时候，最开始sex使用的是bool型，毕竟写惯了扣字节的代码了，当时发现一个问题，如果提到的这篇文章这样写，sex输出的是0、2、4、6、8，但是如果将sex改成bool型，输出就变成了0、1、1、1、1，这个就奇怪了，因为ARM标准C规定里bool型虽然是一个特殊类型，但其实是一个对char型的封装，存储空间应该是一个字节，linux的stdint.h头文件的内容和arm不太一样，但是输出地址的时候发现确实占用了内存。

实际上我想确定的是我将值赋给bool型变量的时候什么时候被变成1的，最开始我改变了解析：

```c++
printf("age: %d, sex: %d\n", (pStudents + i)->age, (int)((pStudents + i)->sex));
```

强制转换成int型变量输出，但是没有效果，还是1，既然不是拿出来的时候变得，那就是存进去的时候变得了，写一个uint8_t类型的指针改变bool变量内存区域的数据：

```c++
uint8_t *p;
/* ...... */
 
for(i = 0; i < 5 ;i++)
{   
        (pStudents + i)->age = i;
        p = &((pStudents + i)->sex);
        *p = 2 * i;
}
```

这一次改变成功了，输出变成了0、2、4、6、8，我猜测是因为是gcc的事，gcc在编译的过程中将bool类型变量的非零值变成1，0保持0，所以才有了这样的结果。