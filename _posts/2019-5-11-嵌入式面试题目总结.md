---
layout: post
title: 嵌入式面试题目总结
author: 宋强
tags: linux
date: 2019-05-11 22:10 +0800
---

# uboot启动过程

1. 先在汇编里面设置中断向量表和各种模式下的堆栈。
2. 关闭FIQ和IRQ，防止程序跑到非预期位置。
3. 关闭MMU和Cache。
4. 进入板级初始化阶段，初始化时钟、内存和串口等外设，还会关闭看门狗。
5. 设置各种模式下的堆栈，准备C语言的运行环境，之后跳转到
6. uboot启动后芯片要处于SVC模式下。

# linux启动过程

# 为什么uboot的启动过程中要关闭cache

* ICache：设备上电时，内存比cpu的初始化慢一拍，而Cache是为了加快读取内存而使用的，如果内存还没准备好就对内存进行读取，很有可能会造成指令取址异常。
* DCache：用于虚拟地址映射，只有在开启MMU后才有意义。

# nand flash和nor flash区别

nand flash没法直接寻址，而nor flash可以直接寻址，所以可以XIP。

# uboot如何传参给内核

将基本参数放在R0-R2中，包括：
* R0：0x0。
* R1：机器号。
* R2：参数地址，地址下有标准参数表。

# linux内存管理的方式

# 7种IPC方式

1. 管道
2. 命名管道
3. 共享内存
4. 消息队列
5. 信号量
6. 信号
7. 套接字

# 内核的8种锁

1. 原子操作：通常用于资源的引用计数，提供一些原子操作函数用于增减某个原子变量。
2. 自旋锁（spinlock）：特点是持有者不会睡眠，通常要求持有时间很短。持有自旋锁的进程不可被抢占，所以要求内核可抢占或者使用SMP，否则会进入死锁。
3. 读写锁（rwlock）：是一种特殊的自旋锁，规定了访问者分为读者和写者，只允许一个写者或者多个读者。
4. 顺序锁（seqlock）：相比读写锁，允许写者和读者同时存在。拥有一个sequence变量， 如果有数据写过则sequence值改变，读进程发现sequence改变则放弃数据，而且有一个特别之处在于被保护的共享资源不可以有指针，因为写者可能使指针失效从而导致读着出现空指针错误。
5. RCU（Read-Copy-Update）：写者写时先拷贝，然后在没有读者的时候写回去。
6. 互斥量（mutex）：相当于数值仅为1的信号量。
7. 信号量（semaphore）：有一个初始值，每个持有进程减去一个。
8. 读写信号量（rw_semaphore）：写者读者互斥，有且只有一个写者可以拥有信号量，没有写者的时候可以多个读者都拥有信号量。

# Linux下用户态与内核态的4种通信方式

1. ioctl（单向，用户到系统）
2. proc 用户向内核读数据
3. 内存映射 自定义一个设备，设备处理函数中自定义page fault，并将其页空间在用户空间通过mmap映射
4. netlink BSD socket的扩展，专门用于内核和用户空间的socket通信 netlink同时用端口和协议号来构建地址体系

# open read等系统调用的整个流程

1. 调用操作系统函数将所有参数和系统调用号放到CPU寄存器中。
2. 这个函数还会触发0x80的trap指令，将CPU从常态切换到管态，开始执行0x80处的程序。、
3. 调用system_call函数，校验各个参数，找到合适的系统调用函数然后执行。
4. 返回到trap handler然后返回用户空间。
5. 封装函数还会根据返回值设置errno的值。

# i2c,spi,uart各自优缺点

* i2c 线少，可以一对多，但是速度慢，半双工且通信要主机发起
* spi 速度快，可以一对多，但是线多，全双工但通信需主机发起
* uart 速度适中，线少，但是一对一，全双工且双发都可发起通讯

# 在宏里面使用可变参数

```c++
#define err(...) fprintf(stderr,__VA_ARGS__)
err("%s %d/n","The error code: ",48);
```

# typedef与define在类型替换中的差别

```c++
#define dPS struct s *
typedef struct s * tPS

dPS p1, p2;     //p1与p2类型不同，p2为struct s类型。
tPS p3, p4;
```

# ARM部分

ARM微处理器有31个通用寄存器和6个状态寄存器。

协处理器的主要作用：

1. MMU控制。
2. 指令和数据缓存。
3. 写缓冲。

通用寄存器分三类，未分组寄存器r0-r7，分组寄存器r8-r15，程序计数器pc。

## 出现异常时ARM处理器的响应步骤：

1. 将下一条指令的地址存入LR，Thumb为PC+4而ARM为PC+8。
2. 将CPSR复制到SPSR中。
3. 根据异常类型置位CPSR中的相应位。
4. 将PC指向异常向量表中相应的位置，跳转执行异常处理程序。

## ARM处理器的七种工作模式

* 用户模式
* 快速中断模式
* 普通中断模式
* 特权模式
* 数据访问终止模式
* 未定义指令终止模式
* 系统模式

## ARM处理器的七种异常模式

* 复位异常
* 未定义指令异常
* 软件中断
* 指令预取终止
* 数据中止异常
* 中断请求异常
* 快速中断请求异常

## FIQ比较快的原因

* FIQ放在最后一位可以将FIQ的中断处理程序紧跟着异常向量表而节省跳转时间，增加FIQ响应速度。
* FIQ模式下r8-r14独有，FIQ可以不需要保存现场。

复位后ARM处理器处于SVC的ARM状态。

## ARM系统中参数的传递方式

小于等于四个的时候使用r0-r3传递，大于等于四个的部分用栈传递。

## ARM有哪几种伪指令

* 符号定义伪指令
* 数据定义伪指令
* 汇编控制伪指令
* 宏指令
* 一些其他为指令

## ARM处理器的9种基本寻址方式

* 寄存器寻址
* 立即寻址
* 寄存器偏移寻址
* 寄存器间接寻址
* 基址寻址
...

## ARM指令集分为6类

* 跳转指令
* 数据处理指令
* 程序状态寄存器传输指令
* Load/Store指令
* 协处理器指令
* 异常中断产生指令

PC指向的是正在取指的指令地址。

