---
layout: post
title: 《王道程序员面试宝典》笔记 - 第9章 面向对象编程
author: 宋强
tags: c++ 笔试
date: 2018-04-17 20:10 +0800
---

# 继承

## 单继承

```c++
class <child-class-name>:<inherit-type> <base-class-name>{
        <new-members>
};
```
inherit-type是指public, private或者protected中的一种，具体影响见下节三种派生方式下的访问权限．

##多继承

```c++
class <child-class-name>:<inherit-type1> <base-class-name1>, <inherit-type2> <bas-class-name2>, ...{
        <new-members>
};
```
### 多继承中的多份同名成员　<span>如果一个类有多个直接基类，而这些基类有有一个共同的基类的话，这个子类中会存在多分这个共同基类的同名成员．要解决这个问题需要使用虚继承，虚继承的话公共基类成员在子类中仅会有一份拷贝．</span>

###　三种派生方式下的访问权限
| 基类成员 | private | protected | public  | private | protected | public    | private | protected | public |
|----------|---------|-----------|---------|---------|-----------|-----------|---------|-----------|--------|
| 派生方式 |         | private   |         |         | protected |           |         | public    |        |
| 派生类中 | 不可见  | private   | private | 不可见  | protected | protected | 不可见  | protected | public |
| 外部     | 不可见  | 不可见    | 不可见  | 不可见  | 不可见    | 不可见    | 不可见  | 不可见    | 不可见 |

派生方式类似一个水口，比本身小会让本身变小，否则就用本身的。也可以理解为两个中用更小的。

## 类间的转换（多态）

* 公有继承方式下，子类对象、子类指针和子类引用可以直接赋值给父类对象、父类指针和父类引用，会发生隐式转换，不需要写明类型转换。
* 基类指针与基类引用可以通过强制转换的方式赋值给子类指针或子类引用，但是基类对象不可以通过强制转换赋值给子类对象。
* 一个指向基类的指针可以指向他的公有派生类的任何对象。

## 多重继承中的多个this指针问题

多重继承中一个类可能会存在多个基类，多个基类就会有多个this指针，这会引出一个特殊情况：**将子类指针赋值给基类时，基类指向的是子类指针中不同的位置。**

比如存在以下三个类：

```c++
class A {
        char data[16];
};

class B {
        char data[16];
};

class C: public A, public B {
        char data[16];
};
```

那么class C实际上的内存结构为：

| A | 16字节 |
|:-:|:------:|
| B | 16字节 |
| C | 16字节 |

如果有如下代码：

```c++
C c;
A *ra = &c;
B *rb = &c;
C *rc = &c;
```

假设c的地址值为0xffff1000，那么ra的值就是0xffff1000，而rb的值实际上是0xffff1010，也就是

| ra与rc -\> | A | 16字节 |
|:----------:|:-:|--------|
|   rb -\>   | B | 16字节 |
|            | C | 16字节 |

所以尽管他们的地址值不一样，但是当出现比较的时候，(ra == rc)与(rb == rc)都会返回真，这个主要是因为在作比较的时候，子类会被隐式转换成基类类型的对象，而当rc转换成B *的时候自然就会地址增加16个字节变成和rb一样了。

参考$P_{157}例1$

## 多基继承问题

如果多重继承中继承的多个类中具有同名成员，则编译器无法判定子类要使用的是哪一个基类中的成员，这个叫做**对基类成员访问的二义性问题**。

使用成员名限定来消除二义性。

```c++
class A {
public:
        void print() {
                cout << "Hello, this is A" << endl;
        }
};

class B {
public:
        void print() {
                cout << "Hello, this is B" << endl;
        }
};
```

### 方式一

```c++
class C : public A, public B {
public:
        void disp() {
                A::print();
        }
}
```

### 方式二

```c++
class C : public A, public B {
public:
        void print() {  //会发生隐藏
                A::print();     //根据需要选择调用A类的print还是B类的print，以实现更好的封装。
        }
}
```

## 菱形继承问题

假如存在以下几个类：

```c++
class A {
public:
        void print() {
                cout << "This is A" << endl;
        }
};
class B : public A {};
class C : public A {};
class D : public B, public C {};

void main () {
        D d;
        A *pa = (A*)&d;
}
```

这个时候D中的内存结构为：

| A |
|:-:|
| A |

将D的指针转换成A的时候出现了菱形多重继承带来的二义性，编译器会报错。

解决方法是先将D\*类型转换为B\*类型或者C\*类型再转换成A\*类型指定上行转换路径：

```c++
void main () {
        D d;
        A *pa = (A*)(B*)&d;
        A *pa = (A*)(C*)&d;
}
```

将A定义为virtual也可以解决这个问题。

# 转换构造函数

如果一个类的构造函数只有一个参数，其他的都没有或者有缺省值，那么可以直接用这个参数赋值给先前的类进行构造，本质上是一种隐式转换。
例如：

```c++
class Integral {
        public Integral(int);
private:
        int real;
};

Ingegral integ = 1;
```
* 如果赋值的对象可以隐式转换成参数类型(如int可以转换成float类型)，则也可以。
* 通过将构造函数声明explicit，可以禁止这种隐式转换。